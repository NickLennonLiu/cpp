# PA1b Zuma 解题报告

计95	刘玉河	2019011560

1. ##### 错误类型：Runtime Error
   
   ###### 错误原因： 
   
   当消除珠子发生在字符串的最左端时，下一次调用play()时传入的参数为left-1 = 0-1 = -1，rank = -1，此时
   `char color = a[rank]`越界访问数组，访问到的数据是未定义的，有可能影响程序执行流程，最终把非代码段的数据当成指令执行，造成Runtime Error

   ###### 构造思路：
   
   为了让rank = -1，只需要使消珠子的位置发生在开头即可，如
   ```
   AAB
   1
   1 A
   ```
   
2. ##### 错误类型：Time Limit Exceeded

    ###### 错误原因：

    程序使用string库的insert()函数进行字符插入，而insert的时间复杂度是O(n)（n为字符串当前长度）的，在最坏情况下，m次操作的时间消费将达到O(m(m+n))，超出了题目所允许的最长时间。

    此外，程序在决定play()迭代的next参数时，先判断left是否为0，如果为0再判断left是否小于a.size()。事实上，第一个条件判断是没有必要的，因为一段珠子消除后，可能发生消除的只有可能在与其相邻的两个珠子，因此选取next时只需要选择消除序列的后一个珠子即可。这多出来的条件判断增大了play()的常数系数。

    ###### 构造思路：

    按照最大规模，持续在序列开头以长度为2为间隔插入珠子序列（如AABBAABBAABB），这样能够在使每次插入的时间消耗达到最坏情况的同时，尽可能延长play()的消耗时间，从而增大了常数系数，导致程序用时超时。

3. ##### 错误类型：Time Limit Exceeded

    ###### 错误原因：

    程序使用string库的insert()函数进行字符插入，而insert的时间复杂度是O(n)（n为字符串当前长度）的，在最坏情况下，m次操作的时间消费将达到O(m(m+n))，超出了题目所允许的最长时间。

    ###### 构造思路：

    按照最大规模，持续在序列开头以长度为2为间隔插入珠子序列（如AABBAABBAABB），这样能够在使每次插入的时间消耗达到最坏情况的同时，尽可能延长play()的消耗时间，从而增大了常数系数，导致程序用时超时。

4. ##### 错误类型：Wrong Answer

   ###### 错误原因：

   寻找最左端相同颜色的珠子时，left在循环结束后没有+1,这样会导致两个问题：
   1. 导致left指向的字符并非当前颜色，执行erase后会将这个不同颜色的删去
   2. 读取到的相同颜色珠子数right - left要比实际多1，这样即使只有两个珠子，也会发生删除

   ###### 构造思路：

   当消除的珠子位于序列开头时不会出现这种错误（有判断left是否为0），因此构造一个消除发生在序列中/后部的测例即可，如
   ```
   AB
   1
   1 B
   ```

5. ##### 错误类型：Wrong Answer

   ###### 错误原因：

   程序开头用`cin >> a;`读入字符串，但cin会忽略开头的空白字符，因此如果初始序列为空，则程序将会读入第二行的m作为初始序列，导致整体出错

   ###### 构造思路：

   使初始序列为空即可

6. ##### 错误类型：Time Limit Exceeded

    ###### 错误原因：

    程序缺乏调整块状数组中各个块的大小的操作，初始序列的长度决定了整个运行过程中块状数组的块的数目。当初始序列长度为0或1时，该块状数组便退化成为普通数组，插入操作消耗时间变为O(n)，将无法满足题目的时间要求。

    ###### 构造思路：

    令初始序列长度为0，然后不断在序列开头插入相邻不同的字符，数量达到题目限制数据范围。

7. ##### 错误类型：Runtime Error

   ###### 错误原因：

   在进行checkLeft()和checkRight()操作后，lParent(rParent)指针有可能指向HEAD(END)，程序在未检测其对应节点的size是否为0时直接访问了里面的向量成员的元素`char left = lParent->balls[head];`使得结构体重载的[]运算符函数还未返回就到达函数结尾，造成SIGSEGV错误。

   ###### 构造思路：

   使珠子相消发生在序列开头或结尾。

8. ##### 错误类型：Wrong Answer

    ###### 错误原因：

    进行“将head向右挪动一格”操作时，程序为了保证head的下一格不超过当前节点的末尾而进行了循环，但忽略了节点的大小size为1时的终止情况：

    > 如果序列中节点的大小为1，那么这段循环并不会在找到了head的下一格时及时停止，而是继续寻找下一格节点，直到遇到大小大于等于2的节点。

    这样一来，head的最终位置并非消除序列的开头，导致消除操作结果出错。

    ###### 构造思路：

    1. 让初始序列尽可能小使得每个节点的大小为1、或者是利用之前的消除制造大小为1的节点
    2. 使消除序列的开头的节点大小为1，因此需要将插入的位置位于原来序列的中间或者尾部

9. ##### 错误原因：Wrong Answer

    ###### 错误原因：

    进行消除操作时，没有判断消除序列的左边界lbound和右边界rbound是否位于同一个块中，并根据lbound和rbound在块中的位置连续更新了所在块的长度两次，第一次plen = l.second - 1，第二次plen = plen - r.second，合计plen = l.second - 1 - r.second，当l,r位于同一个块中时plen最终将为负数，导致对块的长度的维护失败。如果继续插入更多不会引发消除的珠子，则该块的长度将恢复到正数，调用p2a()时不会产生RE,但输出结果时由于块的长度出错，输出的内容也随之出错。

    ###### 构造思路：

    由于程序对块的初始长度设得较大（2048），故只要构造一个较短的序列，同时注意让消除发生在序列中部（非头尾），就能保证lbound与rbound位于同一个块内，导致块长度为负数。接着在操作结束之前利用添加不相同的珠子，将该块长度恢复到正数，使得程序“成功”打印出错误长度的最终序列。

10. ##### 错误原因：Wrong Answer

    ###### 错误原因： 

    在每一次消除操作后，标记查找区段右端的Rank变量r直接被设置为左端l的下一个位置（`r = l;r.second += 1`），这样做只考虑了消除发生在同一个块的中部的情况。
    
如果消除操作涉及两个及以上的块（考虑l和r所在块），那么继续查找需要消除的珠子时l和r应当位于不同的块。程序如此错误地设置r的起始位置，将导致无法发现更多需要消除的珠子，最终的序列中存在未消除的珠子序列。
    
###### 构造思路：
    
考虑到程序设置每个块的初始大小为2048，构造一个初始序列长度为2048*3，共3个块的测例：
    
    - 第一个块与第三个块中的珠子对称分布，即前者开头为AABB...，后者末尾为...BBAA，使得在正确操作下，若第二个块被消除完毕，第一、三个块应当互相完全抵消。
    - 第二个块同样按照对称分布，只在内部一个位置留下2个连续的珠子，如CCDD...EEFFE...DDCC，使得在正常操作下在2个连续珠子处插入对应珠子时，第二个块也会被完全消除。注意第二个块中使用的字符不与第一和第三个块中的字符相同。
    
    进行一次插入操作后，程序成功将第二个块中的所有珠子消除，但接下来l对应的字符将为第一个块的最后一个字符B，r对应的字符为第一个块最后一个字符B的后一个字符（按照数组存储顺序，应当为第二块的第一个字符C），二者对应的字符不同，后续的一、三块消除不会发生。正确答案应当为空序列，但程序输出了第一个块和第三个块中的全部内容。

    
    
    