### PA2a 2-1 Build

计95 刘玉河 2019011560

#### 数据结构：二叉树实现多叉树

每个节点Node记录四个方向：

- 父节点：parent
- 首孩子：lc (firstChild)
- 前兄弟：brother (elder brother/previous sibling)
- 后兄弟：rc (younger brother/next sibling)

以及三个属性：

- 子树高度height
- 子树规模size
- 懒惰标记lazytag

每次发生节点插入、删除时，需要更新节点的四个方向。

#### 算法设计思路与要点

##### 节点查找

沿着路径查找节点，需要在后续路径无效时及时返回最后有效的节点（类似课件中_hot的作用。

##### 子树移动

由于插入的目标节点的路径是对于摘除了子树后的树而言，因此需要先查找并摘除子树，再查找目标节点并插入。

##### 高度维护

**当移动操作过于频繁而询问次数较少时**，每次移动后立刻维护高度并不经济，故需要引入懒惰标记lazytag：每次分离子树和插入子树后，从父节点开始沿祖先向上给每个节点打tag，直到遇到根节点或已经打了tag的节点。

但**并不是每次分离和插入之后都导致高度的更新**，因此还需要引入条件判断是否进行上述打tag的操作：

- 在分离/插入子树后，立刻维护父节点的高度：
    - 如果父节点高度改变，说明分离/插入的子树是父节点子树中最高的一棵，需要沿途向上维护高度。
    - 如果父节点高度未改变，则分离/插入的子树不影响任何一棵子树的高度，则不需要进行维护。

##### 查询高度

若查询的节点带有懒惰标记，则递归地维护子树的高度。

#### 遇到的问题与解决

TLE：当多叉树退化以一条极大路径为”主链“时，频繁的（子树移动+高度查询）操作会导致时间复杂度无法符合题目要求，原因是每次高度查询的时间都达到了最坏的情况。

解决方案：引入打懒惰标记前的简单判断（详见算法设计思路部分）

#### 复杂度分析

##### 时间复杂度

单次移动：$O(cost_{src} +cost_{dst})$，其中cost为待查询位置表示中的路径的路径长度及其中所有rank之和。移动过后所引发的标记所用时间为$O(log n)$，不超过$O(cost_{src} +cost_{dst})$。

单次规模查询：$O(cost)$

单次高度查询：

- 最好情况（路径上节点的高度均不需要更新）：$O(cost)$
- 最坏情况（路径上每个节点高度均需要更新，且路径节点的所有子节点覆盖了全点集）：$O(n)$

- 容易判断，绝大多数次高度查询的时间消耗接近$O(cost)$

##### 空间复杂度

$O(n)$：多叉树的每个节点所用空间为$O(1)$