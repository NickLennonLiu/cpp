### PA2a 2-3 Graph

计95 刘玉河 2019011560

#### 数据结构与算法

##### 最短路径数：Dijkstra + 动态规划

为了后续的询问操作，需要分别从起点1和终点n开始做两遍Dijkstra算法

##### 零边的处理：并查集

思路：由相连接的零边所联通的点之间构成一个集合，该集合内的节点共享最短距离以及最短路径数，故可以采用并查集进行处理。

输入所有的边后，先遍历一遍边集，遇到零边时将两端节点在并查集中合并。

并查集构建完毕后，之后的**所有对于点的操作都在并查集意义下进行**，i.e. 只考虑对应集合中的代表节点。

##### 插入新边后的询问应答

插入新的路径e = (vi,vj) 时，新创造了两条可能的最短路径：

1->vi->vj->n；1->vj->vi->n。

利用经过Dijkstra预处理后得到的dis1、disn计算该两条新的路径的新距离：

1. new_dis1 = dis1[vi] + weight(e) + disn[vj]

2. new_dis2 = dis1[vj] + weight(e) + disn[vi]

根据new_dis1，new_dis2与原先的距离dis1[n]的大小关系，有下面几种情况：

- 最短距离被更新

  （第一条新路径）最短路径数 = 1到vi的最短路径数 × n到vj的最短路径数

  （第二条新路径同理）

  如果两个新距离都是最新的最短距离，那么结果需要将上述两个结果相加

- new_dis1或new_dis2中有与原先最短路径相等的

  将原先的最短路径数加上符合条件的路径所对应的最短路径数，即可得到结果

- new_dis1和new_dis2都大于最短路径长度

  直接返回dijkstra处理过后得到的1到n的最短路径数

#### 遇到的问题与解决

###### 节点数过多（100000），常规Dijkstra算法的O(n^2)复杂度无法满足时间需求

解决：经过与同学交流，查阅课件后改用堆优化版本的Dijkstra算法

#### 复杂度分析

##### 时间复杂度

并查集处理零边：$O(e)$，由于进行了路径压缩，此后每次调用并查集的接口都是$O(1)$的，等同于合并了零边所连接的点。

堆优化后的Dijkstra：$O(e\log v)$

q次询问：$O(q)$

总体时间复杂度：$O(e\log v + q)$

##### 空间复杂度

图：$O(e+v)$

到1、n的最短路径长度/数：$O(4v) = O(v)$

总体复杂度：$O(e+v)$