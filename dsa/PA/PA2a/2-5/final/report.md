### PA2a 2-5 Temperature

计95 刘玉河 2019011560

#### 数据结构与算法：kdTree + quickPartition

##### 预处理：去重

将所有观测站按照坐标大小进行快速排序，然后将坐标重复的观测站合并，只记录它们的最高/最低温度。

##### 建树

从根节点（全体观测站）开始递归建树，轮流按照x，y坐标对指定内存区间的观测站进行快速中位数划分，使得kdTree的高度达到$O(\log n)$

##### 查询

从根节点开始递归查询，其中需要注意两个重要的减少查询节点数的措施：

**碰撞箱：**每个节点记录其所包含观测站的坐标极值作为节点的碰撞箱，进行区间查询时，判断节点的碰撞箱是否与查询区间 被包含/相交/不相交，进而决定是否报告节点。

**剪枝：**每个节点记录内部观测站的温度极值，若某一节点的温度极值无法更新已查询到的温度极值（即节点最高温度<=已得最高温度&&节点最低温度>=已得最低温度），则不深入查询该节点，直接返回。

#### 遇到的问题与解决

###### 快速中位数划分

问题：当区间内存在较多重复元素时，不当的快速划分方法无法用较少的划分次数将轴点确定在区间中点，从而导致建树过程的时间复杂度激增。

采取措施：参考第14章课件中多个版本的partition函数，利用简单的数组进行实验，经过实验后，确定**DUP’版本的快速划分**能够在“数组中全部为重复元素”时能够**只经过一次划分就将轴点确定在中点**。同时，将每次划分时初始选取的轴点从**随机选取改为固定选取区间中点**，同样有利于处理大量重复元素的情况。

#### 复杂度分析

##### 时间复杂度

去重(快速排序+遍历)$O(n\log n + n) = O(n\log n)$,	快速划分$O(n)$

###### 建树:

$T(n) = T(n/2) + O(n) \implies T(n) = O(n\log n)$

###### 询问：

报告子树：$O(r)$,	搜索：$Q(1) = O(1), \quad Q(n) = 2 + 2Q(n/4) \implies Q(n) = O(\sqrt{n})$

###### 总体：

$O(n\log n + n\log n + m(r+\sqrt{n})) = O(n\log n + m(r+\sqrt{n}))$

##### 空间复杂度

树高为$O(\log n)$

树规模$O(n\log n)$

